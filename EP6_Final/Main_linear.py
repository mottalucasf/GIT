#----------------------------------
# Final Project
#
# Lucas Motta Freire - September/20
#----------------------------------
import numpy as np
import matplotlib.pyplot as plt
#auxiliary modules
import integration as intg
import soluction_system_tri as sst
import aux_functions as auxf

# Auxiliary Functions
def exact_soluction(x):
    return x**2 * (x-1)**2

def g(x):
    return 2*x**3 - x**4 -x**2

def k(x):
    return 1


# System Matrix
def system_vectors(n, g, k, q=0):
    '''Parameters:
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    q : 2st Problem weight function
       ...
        
    Return: The lower diagaonal vector, diagonal vector and the system independent vector considering the base of linear splines, in that order'''
    x = np.linspace(0, 1, n+2)
    diag = np.zeros(n)
    sub_diag = np.zeros(n-1)
    ind_vector = np.zeros(n)
    
    for i in range(n):
        diag[i] = (n+1)**2 * intg.integral(x[i], x[i+2], k) 
    for i in range(n-1):
        sub_diag[i] = - (n+1)**2 * intg.integral(x[i+1], x[i+2], k)
    for i in range(n):
        ind_vector[i] = (n+1) * (g(x[i+2]) - 2*g(x[i+1]) + g(x[i]))


    return sub_diag, diag, ind_vector


# approaching solution
def aproximation_soluction(x, n, g, k, q=0):
    '''Parameters:
    x : variable
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    q : 2st Problem weight function
     ...
    Return : Numerical approximation of the solution considering the basis of linear splines'''
    vectors = system_vectors(n, g, k)
    minim_vector = sst.solução_sistema(vectors[0], vectors[1], vectors[0], vectors[2])
    phi = auxf.phi_vector(x,n)

    return np.dot(minim_vector, phi)


# Analyzing the error on the nodes
def erro_nós(n, g, k):
    '''Parameters:
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    ...
    Return : The error coupled by the numerical approximation on the nodes'''
    nos = np.linspace(0, 1, n+2)                            # Generating equally spaced values ​​in the range [0.1]                                         # Guardando os pontos interiores da partição em um array
    u_aprox = np.zeros(n+2)           
    u_exato = np.zeros(n+2)
    for i in range(n+2):
        u_exato[i] = exact_soluction(nos[i])
        u_aprox[i] = aproximation_soluction(nos[i], n, g, k)
    return auxf.erro_infi(u_exato, u_aprox)

def converg_nós(n, g, k):
    '''Parameters:
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    ...
    Return : the value of (error_n / h), to assist in the analysis of the order of convergence on the nodes'''

    erro_n = erro_nós(n, g, k)
    return erro_n * (n+1)**2


# Analyzing the error between nodes
def erro_entre_nós(n, g, k):
    '''Parameters:
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    ...
    Return : The error coupled by the numerical approximation between the nodes'''
    partição = np.linspace(0, 1, 10*n + 1)                            # Gerando valores igualmente espaçados no intervalo [0,1]                                         # Guardando os pontos interiores da partição em um array
    u_aprox = np.zeros(10*n + 1)             
    u_exato = np.zeros(10*n + 1)
    
    for i in range(n+2):
        u_exato[i] = exact_soluction(partição[i])
        u_aprox[i] = aproximation_soluction(partição[i], n, g, k)
    
    return auxf.erro_infi(u_exato, u_aprox)

def converg_entre_nós(n, g, k):
    '''Parameters:
    n : dimension of the problem
    g : Anti-derivative function of the Forcing function(g'' = f)
    k : 1st Problem weight function
    ...
    Return : the value of (error_n / h), to assist in the analysis of the order of convergence between the nodes'''
    erro_n = erro_entre_nós(n, g, k)
    return erro_n * (n+1)**2



#----------------------------------------------- 
# Analisando o erro e a taxa de convergência
#----------------------------------------------
def print_table():
    '''
    Return : Table with an analysis of the error coupled to the numerical approximation of the solution generated by the finite element method
    built through the base of linear splines;
    '''
    n = [15,31,63,127,255]
    #Printing the error comparison table between nodes
    print('Error comparison table between nodes')
    print('n', ' '*14, 'h', ' '*20, 'error', ' '*24, 'error/h^2')
    for x in n:
        print(x, ' '*10, 1/(x+1), ' '*10, erro_entre_nós(x, g, k), ' '*10,  converg_entre_nós(x, g, k))
    print()
    #Printing the error comparison table on the nodes
    print('Node error comparison table')
    print('n', ' '*14, 'h', ' '*20, 'error', ' '*24, 'error/h^2')
    for x in n:
        print(x, ' '*10, 1/(x+1), ' '*10, erro_nós(x, g, k), ' '*10,  converg_nós(x, g, k))



#-----------------------------------------------------------
# Plotando o gráfico de u_barra com relação a solução exata
#-----------------------------------------------------------

def graph_plot(n):
    '''
    Return : Comparative graph between Numerical Approximation and the exact solution
    '''
    x = np.linspace(0, 1, 100)                                      # Gerando valores igualmente espaçados no intervalo [0,1]
    y_1 = np.zeros(100)
    for i in range(100):
        y_1[i] = aproximation_soluction(x[i], n, g, k, q=0)                     # Guardando os valores de u_barra no intervalo [0,1] em uma lista
    plt.subplot(1, 2, 1)
    plt.plot(x , y_1, color='r')
    plt.title('Gráfico da solução numérica')

    plt.subplot(1, 2, 2)
    plt.plot(x, exact_soluction(x))
    plt.title('Gráfico da solução exata')

    plt.show()



graph_plot(255)